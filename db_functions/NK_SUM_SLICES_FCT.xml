<?xml version="1.0" encoding="UTF-8" standalone="no"?><QueryResult xmlns="http://www.niku.com/xog/Query" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
      <Code>capture3c.get_db_function</Code>
      <Records>
        <Record>
          <code>NK_SUM_SLICES_FCT</code>
          <parallel>NO</parallel>
          <definition>
  CREATE OR REPLACE EDITIONABLE FUNCTION "PPM"."NK_SUM_SLICES_FCT" ( P_CURVE IN NK_CURVE, p_calendar CRV_CALENDAR)
  RETURN NK_SLICES PIPELINED  -- enable parallel
  IS
  v_curve_start PLS_INTEGER; v_curve_finish PLS_INTEGER;
  V_SUM NUMBER := 0.0;
  V_START PLS_INTEGER; V_FINISH PLS_INTEGER; V_DATE PLS_INTEGER;
  V_START2 PLS_INTEGER; V_FINISH2 PLS_INTEGER;
  V_DAY_OF_WEEK PLS_INTEGER;
  V_WEEK_TOTAL PLS_INTEGER; V_WEEKS PLS_INTEGER; V_WORK_TIME INTEGER;
  V_IDX PLS_INTEGER;
  V_START_TOD PLS_INTEGER; V_FINISH_TOD PLS_INTEGER;
  V_SEG_LOW PLS_INTEGER; V_SEG_HIGH PLS_INTEGER;
  V_EXCP_LOW PLS_INTEGER; V_EXCP_HIGH PLS_INTEGER; V_EXCP_PTR PLS_INTEGER;
  V_SEARCH_LIMIT PLS_INTEGER;
  V_LAST_EXCP_PTR PLS_INTEGER;
  v_seg_cnt PLS_INTEGER; v_seg_idx PLS_INTEGER; v_period_cnt PLS_INTEGER; v_period_idx PLS_INTEGER;
  v_period_inprogress boolean;
  unexpected_sqlcurve EXCEPTION;


  BEGIN

    if(p_curve IS NULL OR p_curve.segments IS NULL OR p_curve.segments.count = 0 OR p_calendar.count = 0) THEN
      RETURN;
    END IF;

    v_curve_start := p_curve.segments(1).segment_start;
    v_curve_finish := p_curve.segments(p_curve.segments.count).segment_finish;
    v_seg_cnt := p_curve.segments.count;
    v_period_cnt := p_calendar.count;
    v_period_inprogress := FALSE;


    IF(  (p_calendar(1).julian_start &gt; p_curve.segments(p_curve.segments.count).segment_finish )
      OR (p_calendar(1).julian_start = p_curve.segments(p_curve.segments.count).segment_finish and p_curve.segments(p_curve.segments.count).finish_tod = 0)
      OR (p_calendar(p_calendar.count).julian_finish &lt; p_curve.segments(1).segment_start)) THEN
      RETURN;
    END IF;

    v_seg_idx := 1;
    v_period_idx := 1;
    while true LOOP

      -- out of segments
      if(v_seg_idx &gt; v_seg_cnt) then
        if(v_period_inprogress) then
          pipe row( NK_SLICE(p_calendar(v_period_idx).period, p_calendar(v_period_idx).start_date, p_calendar(v_period_idx).finish_date, v_sum/p_calendar(v_period_idx).fte_conversion));
        END IF;
        exit;
      end if;

      -- out of calendar periods
      if(v_period_idx &gt; v_period_cnt) then
        exit;
      end if;

      -- advance to next calendar period
      if(p_calendar(v_period_idx).julian_finish &lt;= p_curve.segments(v_seg_idx).segment_start) then
        if(v_period_inprogress) THEN
          pipe row( NK_SLICE(p_calendar(v_period_idx).period, p_calendar(v_period_idx).start_date, p_calendar(v_period_idx).finish_date, v_sum/p_calendar(v_period_idx).fte_conversion));
          v_sum := 0;
          v_period_inprogress := false;
        end if;

        v_period_idx := v_period_idx + 1;
        continue;
      end if;

      -- advance to next segment
      if(p_calendar(v_period_idx).julian_start &gt; p_curve.segments(v_seg_idx).segment_finish --+ 1
         or (p_calendar(v_period_idx).julian_start = p_curve.segments(v_seg_idx).segment_finish and p_curve.segments(v_seg_idx).finish_tod = 0)) then
        v_seg_idx := v_seg_idx + 1;
        continue;
      end if;

      -- end of a period
      IF(p_curve.segments(v_seg_idx).segment_start &gt; p_calendar(v_period_idx).julian_finish) then
        --WRITE THE SLICE IF A SLICE WAS IN PROGRESS
        if(v_period_inprogress) THEN
          pipe row( NK_SLICE(p_calendar(v_period_idx).period, p_calendar(v_period_idx).start_date, p_calendar(v_period_idx).finish_date, v_sum/p_calendar(v_period_idx).fte_conversion));
          --        v_slice = row(p_calendar[v_period_idx].period, p_calendar[v_period_idx].start_date, p_calendar[v_period_idx].finish_date, v_sum/p_calendar[v_period_idx].fte_conversion);
          --        return next v_slice;
          v_sum := 0;
          v_period_inprogress := false;
        end if;

        v_period_idx := v_period_idx + 1;
        continue;
      end if;

      -- PERIOD INCLUDES ALL OF THE SEGMENT
      if(p_calendar(v_period_idx).julian_start&lt;=p_curve.segments(v_seg_idx).segment_start
         and (p_calendar(v_period_idx).julian_finish&gt;p_curve.segments(v_seg_idx).segment_finish
              or (p_calendar(v_period_idx).julian_finish = p_curve.segments(v_seg_idx).segment_finish and p_curve.segments(v_seg_idx).finish_tod = 0) )) then
        --raise notice 'all of segment';
        v_period_inprogress := true;
        v_sum := v_sum + p_curve.segments(v_seg_idx).segment_sum;
        v_seg_idx := v_seg_idx + 1;
        CONTINUE;
      end if;


      -- PERIOD INCLUDES EXACTLY THAT SEGMENT
      if(p_calendar(v_period_idx).julian_start = p_curve.segments(v_seg_idx).segment_start and p_calendar(v_period_idx).julian_finish = p_curve.segments(v_seg_idx).segment_finish
         and p_curve.segments(v_seg_idx).start_tod = 0 and p_curve.segments(v_seg_idx).finish_tod = 0 ) then
        v_period_inprogress := true;
        V_SUM := v_sum + p_curve.segments(v_seg_idx).segment_sum;
        pipe row( NK_SLICE(p_calendar(v_period_idx).period, p_calendar(v_period_idx).start_date, p_calendar(v_period_idx).finish_date, v_sum/p_calendar(v_period_idx).fte_conversion));
        v_period_inprogress := FALSE;
        v_seg_idx := v_seg_idx + 1;
        v_period_idx := v_period_idx + 1;
        continue;
      end if;

      -- PERIOD INCLUDES PORTION OF THE SEGMENT
      IF(p_calendar(v_period_idx).julian_finish &gt; p_curve.segments(v_seg_idx).segment_start
         and (p_calendar(v_period_idx).julian_start &lt; p_curve.segments(v_seg_idx).segment_finish
              or (p_calendar(v_period_idx).julian_start = p_curve.segments(v_seg_idx).segment_finish and p_curve.segments(v_seg_idx).finish_tod &gt; 0))) then
        v_period_inprogress := true;
        V_START := GREATEST( p_calendar(v_period_idx).julian_start, P_CURVE.SEGMENTS(v_seg_idx).SEGMENT_START);
        V_FINISH := LEAST( p_calendar(v_period_idx).julian_finish, P_CURVE.SEGMENTS(v_seg_idx).SEGMENT_FINISH);


        IF( P_CURVE.SEGMENTS(v_seg_idx).WORK_WEEK_TOTALS IS NOT NULL ) THEN
          /*
            Compute the weekly work time from the calendar
          */
          V_WEEK_TOTAL := 0; V_WORK_TIME := 0;
          V_WEEK_TOTAL := V_WEEK_TOTAL
                          + P_CURVE.SEGMENTS(v_seg_idx).WORK_WEEK_TOTALS(1)
                          + P_CURVE.SEGMENTS(v_seg_idx).WORK_WEEK_TOTALS(2)
                          + P_CURVE.SEGMENTS(v_seg_idx).WORK_WEEK_TOTALS(3)
                          + P_CURVE.SEGMENTS(v_seg_idx).WORK_WEEK_TOTALS(4)
                          + P_CURVE.SEGMENTS(v_seg_idx).WORK_WEEK_TOTALS(5)
                          + P_CURVE.SEGMENTS(v_seg_idx).WORK_WEEK_TOTALS(6)
                          + P_CURVE.SEGMENTS(v_seg_idx).WORK_WEEK_TOTALS(7);

          V_DAY_OF_WEEK := MOD((V_START+6),7)+1;
          V_IDX := V_START;
          /*
            Iterate through the periods daily to add to worktime
           */
          WHILE(V_IDX &lt; V_FINISH) LOOP
            /*
              If a full week is found then shortcut the process by multipling the
              weekly total by the number of full weeks found
            */
            IF(V_DAY_OF_WEEK = 1 AND (V_FINISH - V_IDX) &gt; 7) THEN
              V_WEEKS := trunc((V_FINISH - V_IDX) / 7);
              V_WORK_TIME := V_WORK_TIME + (V_WEEKS * V_WEEK_TOTAL);
              -- reposition to the new day and move on
              V_IDX := V_IDX + (V_WEEKS * 7);
              V_DAY_OF_WEEK := MOD((V_IDX+6),7)+1;
              CONTINUE;
            END IF;

            V_WORK_TIME := V_WORK_TIME + P_CURVE.SEGMENTS(v_seg_idx).WORK_WEEK_TOTALS(V_DAY_OF_WEEK);
            IF(V_DAY_OF_WEEK = 7) THEN
              V_DAY_OF_WEEK := 1;
            ELSE
              V_DAY_OF_WEEK := V_DAY_OF_WEEK + 1;
            END IF;

            V_IDX := V_IDX + 1;
          END LOOP;


          /*
            Need to check for a 1 day segment with either start tod or finish tod
          */
          IF(P_CURVE.SEGMENTS(v_seg_idx).SEGMENT_START = P_CURVE.SEGMENTS(v_seg_idx).SEGMENT_FINISH AND (P_CURVE.SEGMENTS(v_seg_idx).START_TOD &gt; 0 OR P_CURVE.SEGMENTS(v_seg_idx).FINISH_TOD &gt; 0)) THEN
            V_DAY_OF_WEEK := MOD((V_START+6),7)+1;
            -- define the tod boundary
            V_START_TOD := GREATEST(0,P_CURVE.SEGMENTS(v_seg_idx).START_TOD);
            V_FINISH_TOD := LEAST(86400,P_CURVE.SEGMENTS(v_seg_idx).FINISH_TOD);
            FOR ELEM IN 1 .. P_CURVE.SEGMENTS(v_seg_idx).SHIFTS.COUNT LOOP
              IF(P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).DAY_OF_WEEK = V_DAY_OF_WEEK AND (P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).FINISH_TOD &gt; V_START_TOD AND P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).START_TOD &lt;= V_FINISH_TOD)) THEN
                V_WORK_TIME := V_WORK_TIME + (LEAST(P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).FINISH_TOD, V_FINISH_TOD) - GREATEST(P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).START_TOD,P_CURVE.SEGMENTS(v_seg_idx).START_TOD));
              END IF;
            END LOOP;
          ELSE

            /*
              check for first day stuff here
            */
            IF(P_CURVE.SEGMENTS(v_seg_idx).START_TOD &gt; 0 AND V_START = P_CURVE.SEGMENTS(v_seg_idx).SEGMENT_START AND P_CURVE.SEGMENTS(v_seg_idx).SHIFTS IS NOT NULL) THEN
              V_DAY_OF_WEEK := MOD((V_START+6),7)+1;
              V_WORK_TIME := V_WORK_TIME - P_CURVE.SEGMENTS(v_seg_idx).WORK_WEEK_TOTALS(V_DAY_OF_WEEK);
              -- get the sume from the shifts for the day
              FOR ELEM IN 1 .. P_CURVE.SEGMENTS(v_seg_idx).SHIFTS.COUNT LOOP
                IF(P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).DAY_OF_WEEK = V_DAY_OF_WEEK AND P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).FINISH_TOD &gt; P_CURVE.SEGMENTS(v_seg_idx).START_TOD) THEN
                  V_WORK_TIME := V_WORK_TIME + (P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).FINISH_TOD - GREATEST(P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).START_TOD,P_CURVE.SEGMENTS(v_seg_idx).START_TOD));
                END IF;
              END LOOP;
            END IF;

            /*
              check for last day stuff here
            */
            IF(P_CURVE.SEGMENTS(v_seg_idx).FINISH_TOD &gt; 0 AND V_FINISH = P_CURVE.SEGMENTS(v_seg_idx).SEGMENT_FINISH AND P_CALENDAR(v_period_idx).julian_finish &gt; P_CURVE.SEGMENTS(v_seg_idx).SEGMENT_FINISH AND P_CURVE.SEGMENTS(v_seg_idx).SHIFTS IS NOT NULL) THEN
              V_DAY_OF_WEEK := MOD((V_FINISH+6),7)+1;
              -- get the sume from the shifts for the day
              FOR ELEM IN 1 .. P_CURVE.SEGMENTS(v_seg_idx).SHIFTS.COUNT LOOP
                IF(P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).DAY_OF_WEEK = V_DAY_OF_WEEK AND P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).START_TOD &lt; P_CURVE.SEGMENTS(v_seg_idx).FINISH_TOD) THEN
                  V_WORK_TIME := V_WORK_TIME + (LEAST(P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).FINISH_TOD,P_CURVE.SEGMENTS(v_seg_idx).FINISH_TOD) - P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).START_TOD);
                END IF;
              END LOOP;
            END IF;
          END IF;

          /*
             Now iterate through the exceptions and backout the total
             from the work week and add the exception
          */
          IF( P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS IS NOT NULL AND P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS.COUNT &gt; 0 ) THEN
            V_EXCP_LOW := 1;
            V_EXCP_HIGH := P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS.COUNT;

            /*
              Only need to process exceptions if the requested date range is between the first start and the last finish then process exceptions
            */
            IF(V_FINISH &gt;= P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(V_EXCP_LOW).START_DATE AND V_START &lt;= P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(V_EXCP_HIGH).FINISH_DATE) THEN
              /*
                Implemented a binary search here for the mitre case where there are hundreds of exceptions for the segment. Look for any exception
                that contains the requested start date
               */
              IF(V_EXCP_HIGH &gt; 5) THEN
                -- This loop in place to avoid unintended infinite loop.  20 is the max number of binary searches for 1M items so should be plenty
                FOR bi IN 1 .. 20 loop
                  V_LAST_EXCP_PTR := V_EXCP_PTR;
                  V_EXCP_PTR := V_EXCP_LOW + ((V_EXCP_HIGH - V_EXCP_LOW)/2);

                  -- could be that there is no exception that starts on that date -- weekends
                  IF( V_LAST_EXCP_PTR = V_EXCP_PTR OR V_EXCP_LOW = V_EXCP_HIGH) THEN
                    EXIT;
                  END IF;

                  -- found it
                  IF(V_START &gt;= P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(V_EXCP_PTR).START_DATE AND V_START &lt;= P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(V_EXCP_PTR).FINISH_DATE) THEN
                    V_EXCP_LOW := V_EXCP_PTR;
                    EXIT;
                  END IF;

                  -- move back
                  IF(V_START &lt; P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(V_EXCP_PTR).START_DATE) THEN
                    V_EXCP_HIGH := V_EXCP_PTR;
                    CONTINUE;
                  END IF;

                  -- move forward
                  IF(V_START &gt; P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(V_EXCP_PTR).FINISH_DATE) THEN
                    V_EXCP_LOW := V_EXCP_PTR;
                    CONTINUE;
                  END IF;
                END LOOP;  -- safety loop
              END IF; -- IF &gt; ? THEN do BINARY search

              -- now that the low has been established, reset the high to the count
              v_excp_high := p_curve.segments(v_seg_idx).exceptions.count;

              /*
                Iterate through the exceptions
               */
              FOR e_idx IN V_EXCP_LOW .. V_EXCP_HIGH LOOP
                IF(P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).FINISH_DATE &lt; V_START) THEN
                  CONTINUE;
                END IF;

                IF(P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).START_DATE &gt; V_FINISH) THEN
                  EXIT;
                END IF;

                -- the exception fits the date range so process it
                IF(P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).START_DATE &lt;= V_FINISH AND P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).FINISH_DATE &gt; V_START) THEN
                  --dbms_output.put_line('EXCP:' || P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(E_IDX).START_DATE);
                  V_START2 := GREATEST( P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).START_DATE, V_START);
                  V_FINISH2 := P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).FINISH_DATE - 1; -- natively stored as the next day, like a midnight date

                  V_DAY_OF_WEEK := MOD((V_START2+6),7)+1;
                  /*
                    each date in the exception should be considered including v_finish2
                   */
                  FOR V_DATE IN V_START2 .. (V_FINISH2) LOOP
                    -- if date &gt; seg finish quit
                    IF(V_DATE &gt; P_CURVE.SEGMENTS(v_seg_idx).SEGMENT_FINISH) THEN
                      EXIT;
                    END IF;

                    -- if date = segment finish and doesn't have a tod quit
                    IF(V_DATE = P_CURVE.SEGMENTS(v_seg_idx).SEGMENT_FINISH AND P_CURVE.SEGMENTS(v_seg_idx).FINISH_TOD = 0) THEN
                      EXIT;
                    END IF;

                    -- if date &gt;= the query finish then exit
                    IF(V_DATE &gt;= P_CALENDAR(v_period_idx).julian_finish) THEN
                      EXIT;
                    END IF;

                    -- backout the worktime from the calendar
                    IF(P_CURVE.SEGMENTS(v_seg_idx).SHIFTS IS NOT NULL) THEN

                      -- 1 day segment equals start and finish and either start_tod &gt; 0 or finish_tod &gt; 0
                      IF(V_DATE = P_CURVE.SEGMENTS(v_seg_idx).SEGMENT_START and V_DATE = P_CURVE.SEGMENTS(v_seg_idx).SEGMENT_FINISH and (P_CURVE.SEGMENTS(v_seg_idx).START_TOD &gt; 0 or P_CURVE.SEGMENTS(v_seg_idx).FINISH_TOD &gt; 0)) then
                        -- define the tod boundary
                        V_START_TOD := GREATEST(0,P_CURVE.SEGMENTS(v_seg_idx).START_TOD);
                        V_FINISH_TOD := LEAST(86400,P_CURVE.SEGMENTS(v_seg_idx).FINISH_TOD);
                        FOR ELEM IN 1 .. P_CURVE.SEGMENTS(v_seg_idx).SHIFTS.COUNT LOOP
                          IF(P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).DAY_OF_WEEK = V_DAY_OF_WEEK AND (P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).FINISH_TOD &gt; V_START_TOD AND P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).START_TOD &lt;= V_FINISH_TOD)) THEN
                            V_WORK_TIME := V_WORK_TIME - (LEAST(P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).FINISH_TOD, V_FINISH_TOD) - GREATEST(P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).START_TOD,P_CURVE.SEGMENTS(v_seg_idx).START_TOD));
                          END IF;
                        END LOOP;

                      -- segment start date with a start tod
                      ELSIF(V_DATE = P_CURVE.SEGMENTS(v_seg_idx).SEGMENT_START and P_CURVE.SEGMENTS(v_seg_idx).START_TOD &gt; 0) then
                        -- get the sum from the shifts for the day
                        FOR ELEM IN 1 .. P_CURVE.SEGMENTS(v_seg_idx).SHIFTS.COUNT LOOP
                          IF(P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).day_of_week = v_day_of_week and P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).finish_tod &gt; P_CURVE.SEGMENTS(v_seg_idx).start_tod ) THEN
                            V_WORK_TIME := V_WORK_TIME - (P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).finish_tod - greatest(P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).start_tod,P_CURVE.SEGMENTS(v_seg_idx).start_tod));
                          END IF;
                        END LOOP;

                      -- segment finish date with a finish tod
                      ELSIF(V_DATE = P_CURVE.SEGMENTS(v_seg_idx).SEGMENT_FINISH and P_CURVE.SEGMENTS(v_seg_idx).FINISH_TOD &gt; 0) then
                        FOR ELEM IN 1 .. P_CURVE.SEGMENTS(v_seg_idx).SHIFTS.COUNT LOOP
                          IF(P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).day_of_week = v_day_of_week and P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).start_tod &lt; P_CURVE.SEGMENTS(v_seg_idx).finish_tod ) THEN
                            V_WORK_TIME := V_WORK_TIME - (least(P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).finish_tod,P_CURVE.SEGMENTS(v_seg_idx).finish_tod) - P_CURVE.SEGMENTS(v_seg_idx).SHIFTS(ELEM).start_tod);
                          END IF;
                        END LOOP;

                      ELSE
                        -- backout the original work time
                        V_WORK_TIME := V_WORK_TIME - P_CURVE.SEGMENTS(v_seg_idx).WORK_WEEK_TOTALS(V_DAY_OF_WEEK);
                      END IF;
                    ELSE
                      -- segment shifts are null so backout the original work time
                      V_WORK_TIME := V_WORK_TIME - P_CURVE.SEGMENTS(v_seg_idx).WORK_WEEK_TOTALS(V_DAY_OF_WEEK);
                    END IF;

                    -- add the exception based time
                    IF(P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).SHIFTS IS NOT NULL) THEN
                      -- 1 day segment
                      IF(V_DATE = P_CURVE.SEGMENTS(v_seg_idx).SEGMENT_START and V_DATE = P_CURVE.SEGMENTS(v_seg_idx).SEGMENT_FINISH and (P_CURVE.SEGMENTS(v_seg_idx).START_TOD &gt; 0 or P_CURVE.SEGMENTS(v_seg_idx).FINISH_TOD &gt; 0) and P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).shifts is NOT NULL) THEN

                        -- loop through the shifts on the exception
                        V_START_TOD := GREATEST(0,P_CURVE.SEGMENTS(v_seg_idx).START_TOD);
                        V_FINISH_TOD := LEAST(86400,P_CURVE.SEGMENTS(v_seg_idx).FINISH_TOD);
                        FOR ELEM in 1 .. P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).SHIFTS.COUNT LOOP
                          IF((P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).SHIFTS(ELEM).FINISH_TOD &gt; V_START_TOD AND P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).SHIFTS(ELEM).START_TOD &lt;= V_FINISH_TOD)) THEN
                            V_WORK_TIME := V_WORK_TIME + (LEAST(P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).SHIFTS(ELEM).FINISH_TOD, V_FINISH_TOD) - GREATEST(P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).SHIFTS(ELEM).START_TOD,P_CURVE.SEGMENTS(v_seg_idx).START_TOD));
                          END IF;
                        END LOOP;

                      -- segment start date with a start tod
                      ELSIF(V_DATE = P_CURVE.SEGMENTS(v_seg_idx).SEGMENT_START and P_CURVE.SEGMENTS(v_seg_idx).START_TOD &gt; 0 and P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).SHIFTS IS NOT NULL) THEN
                        -- loop through the shifts on the exception
                        FOR ELEM IN 1 .. P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).SHIFTS.COUNT LOOP
                          IF(P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).SHIFTS(ELEM).finish_tod &gt; P_CURVE.SEGMENTS(v_seg_idx).start_tod ) then
                            V_WORK_TIME := V_WORK_TIME + (P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).SHIFTS(ELEM).finish_tod - greatest(P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).SHIFTS(ELEM).start_tod,P_CURVE.SEGMENTS(v_seg_idx).start_tod));
                          END IF;
                        END LOOP;

                      -- segment finish date with a finish tod
                      ELSIF(V_DATE = P_CURVE.SEGMENTS(v_seg_idx).SEGMENT_FINISH and P_CURVE.SEGMENTS(v_seg_idx).FINISH_TOD &gt; 0 and P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).shifts is not null) THEN
                        -- loop through the shifts on the exception
                        FOR ELEM in 1..P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).SHIFTS.COUNT loop
                          IF(P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).SHIFTS(ELEM).start_tod &lt; P_CURVE.SEGMENTS(v_seg_idx).finish_tod ) THEN
                            V_WORK_TIME := V_WORK_TIME + (least(P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).SHIFTS(ELEM).finish_tod,P_CURVE.SEGMENTS(v_seg_idx).finish_tod) - P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).SHIFTS(ELEM).start_tod);
                          END IF;
                        END LOOP;

                      ELSE
                        -- get the total shifts from the exception
                        V_WORK_TIME := V_WORK_TIME + P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).TOTAL;
                      END IF; -- e.shifts NOT NULL
                    ELSE
                      -- get the total shifts from the exception because the shifts were null
                      V_WORK_TIME := V_WORK_TIME + P_CURVE.SEGMENTS(v_seg_idx).EXCEPTIONS(e_idx).TOTAL;
                    END IF;  -- e.shifts not null

                    -- advance day of week
                    IF(V_DAY_OF_WEEK = 7) THEN
                      V_DAY_OF_WEEK := 1;
                    ELSE
                      V_DAY_OF_WEEK := V_DAY_OF_WEEK + 1;
                    END IF;
                  END LOOP; -- dates in the exception
                END IF; -- EXCEPTION IS IN DATE range
              END LOOP; -- exceptions loop
            END IF; -- exceptions NOT NULL
          END IF; -- vstart BETWEEN FIRST START AND LAST finish
          V_SUM := V_SUM + (V_WORK_TIME * P_CURVE.SEGMENTS(v_seg_idx).RATE);

        ELSE
          -- no calendar so straight computation
          /*
           If a 1 day segment with tod
          */
          IF(P_CURVE.SEGMENTS(v_seg_idx).SEGMENT_START = P_CURVE.SEGMENTS(v_seg_idx).SEGMENT_FINISH AND (P_CURVE.SEGMENTS(v_seg_idx).START_TOD &gt; 0 OR P_CURVE.SEGMENTS(v_seg_idx).FINISH_TOD &gt; 0)) THEN
            IF(P_CURVE.SEGMENTS(v_seg_idx).START_TOD &gt; 0 AND P_CURVE.SEGMENTS(v_seg_idx).FINISH_TOD &gt; 0) THEN
              V_SUM := V_SUM + ((P_CURVE.SEGMENTS(v_seg_idx).FINISH_TOD - P_CURVE.SEGMENTS(v_seg_idx).START_TOD) * P_CURVE.SEGMENTS(v_seg_idx).RATE);
            ELSIF(P_CURVE.SEGMENTS(v_seg_idx).FINISH_TOD &gt; 0) THEN
              V_SUM := V_SUM + (P_CURVE.SEGMENTS(v_seg_idx).FINISH_TOD * P_CURVE.SEGMENTS(v_seg_idx).RATE);
            ELSE
              V_SUM := V_SUM + ((86400 - P_CURVE.SEGMENTS(v_seg_idx).START_TOD) * P_CURVE.SEGMENTS(v_seg_idx).RATE);
            END IF;

          ELSE
            -- multiday sgment
            V_SUM := V_SUM + ((V_FINISH - V_START) * 86400 * P_CURVE.SEGMENTS(v_seg_idx).RATE);

            /*
              check for the start_tod &gt; 0
            */
            IF(P_CURVE.SEGMENTS(v_seg_idx).START_TOD &gt; 0 and v_start = P_CURVE.SEGMENTS(v_seg_idx).segment_start) THEN
              -- subtract the start day
              V_SUM := V_SUM - (86400 * P_CURVE.SEGMENTS(v_seg_idx).RATE);
              -- add the portion
              V_SUM := V_SUM + ((86400 - P_CURVE.SEGMENTS(v_seg_idx).START_TOD) * P_CURVE.SEGMENTS(v_seg_idx).RATE);
            END IF;

            /*
              check for the finish_tod &gt; 0
            */
            IF(P_CURVE.SEGMENTS(v_seg_idx).FINISH_TOD &gt; 0 and v_finish = P_CURVE.SEGMENTS(v_seg_idx).segment_finish and P_CALENDAR(v_period_idx).julian_finish &gt; P_CURVE.SEGMENTS(v_seg_idx).segment_finish) THEN
              V_SUM := V_SUM + (P_CURVE.SEGMENTS(v_seg_idx).FINISH_TOD * P_CURVE.SEGMENTS(v_seg_idx).RATE);
            END IF;
          END IF;
        END IF;

        -- IF PERIOD FINISH &lt; SEGMENT_FINISH BEGIN
        IF(p_calendar(v_period_idx).julian_finish &lt; p_curve.segments(v_seg_idx).segment_finish
           or (p_calendar(v_period_idx).julian_finish = p_curve.segments(v_seg_idx).segment_finish and p_curve.segments(v_seg_idx).finish_tod &gt; 0)) then
          -- WRITE SLICE
          --raise notice 'partial 1';
          pipe row( NK_SLICE(p_calendar(v_period_idx).period, p_calendar(v_period_idx).start_date, p_calendar(v_period_idx).finish_date, v_sum/p_calendar(v_period_idx).fte_conversion));
          V_SUM := 0;
          v_period_idx := v_period_idx + 1;
          v_period_inprogress := false;
          continue;
        end if;

        if(p_calendar(v_period_idx).julian_finish = p_curve.segments(v_seg_idx).segment_finish and p_curve.segments(v_seg_idx).finish_tod = 0) then
          --raise notice 'partial 2';
          pipe row( NK_SLICE(p_calendar(v_period_idx).period, p_calendar(v_period_idx).start_date, p_calendar(v_period_idx).finish_date, v_sum/p_calendar(v_period_idx).fte_conversion));
          V_SUM := 0;
          v_period_idx := v_period_idx + 1;
          v_seg_idx := v_seg_idx + 1;
          v_period_inprogress := false;
          continue;
        end if;

        IF(p_calendar(v_period_idx).julian_finish &gt; p_curve.segments(v_seg_idx).segment_finish) then
          --raise notice 'yo!';
          v_seg_idx := v_seg_idx + 1;
          continue;
        end if;

      end if;

      -- should never get here
      raise unexpected_sqlcurve;

    END LOOP; -- END OF main loop
    RETURN;
  END;</definition>
        </Record>
      </Records>
      <Slice>
        <Number>0</Number>
        <Size>1</Size>
        <Total>1</Total>
      </Slice>
    </QueryResult>
<?xml version="1.0" encoding="UTF-8" standalone="no"?><QueryResult xmlns="http://www.niku.com/xog/Query" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
      <Code>capture3c.get_db_procedure</Code>
      <Records>
        <Record>
          <code>CMN_MODIFY_COLUMN_DATATYPE_SP</code>
          <parallel>NO</parallel>
          <definition>
  CREATE OR REPLACE EDITIONABLE PROCEDURE "PPM"."CMN_MODIFY_COLUMN_DATATYPE_SP" (
   P_TABLE_NAME VARCHAR2,
   P_COLUMN_NAME VARCHAR2,
   P_DATATYPE VARCHAR2
)
AS
   TYPE T_COPY_CURSOR IS REF CURSOR;-- define weak REF CURSOR type

   TYPE CMN_VARCHAR_TAB_TYPE IS TABLE OF VARCHAR2 (4000)
      INDEX BY BINARY_INTEGER;

   CMN_DROP_INDEXES_TAB          CMN_VARCHAR_TAB_TYPE;
   CMN_ADD_INDEXES_TAB           CMN_VARCHAR_TAB_TYPE;
   C_INDEXES_CURSOR              T_COPY_CURSOR;
   V_DROP_INDEX_SQL              VARCHAR2 (1000);
   V_CREATE_INDEX_SQL            VARCHAR2 (1000);
   V_INDEX_NAME                  VARCHAR2 (100);
   V_INDEX_COLUMN_NAME           VARCHAR2 (100);
   V_INDEX_TABLESPACE            VARCHAR2 (100);
   V_INDEX_UNIQUENESS            VARCHAR2 (100);
   V_PREVIOUS_INDEX_TABLESPACE   VARCHAR2 (100);
   V_PREVIOUS_INDEX_NAME         VARCHAR2 (100);
   V_INDEX_SELECT_SQL            VARCHAR2 (1000);
   V_PRIMARY_KEY_SQL             VARCHAR2 (1000);
   C_PRIMARY_KEY_CURSOR          T_COPY_CURSOR;
   V_PRIMARY_KEY_COUNTER         BINARY_INTEGER := 0;
   V_PRIMARY_KEY_CREATE_SQL      VARCHAR2 (1000);
   V_PRIMARY_KEY_DROP_SQL        VARCHAR2 (1000);
   V_PK_CONSTRAINT_NAME          VARCHAR2 (1000);
   V_PK_COLUMN_NAME              VARCHAR2 (1000);
   V_PK_INDEX_SPACE              VARCHAR2 (100);
   V_TRIGGER_RESTORED            BOOLEAN := FALSE;
   V_INDEXES_RESTORED            BOOLEAN := FALSE;

   TYPE V_COLUMN_INFO_TYPE IS RECORD(
      COLUMN_NAME                   VARCHAR2 (100),
      NEW_DATATYPE                  VARCHAR2 (100));

   TYPE V_COLUMN_TAB_TYPE IS TABLE OF V_COLUMN_INFO_TYPE
      INDEX BY BINARY_INTEGER;

   V_COLUMN_TAB                  V_COLUMN_TAB_TYPE;
   V_TABLE_NAME                  VARCHAR2 (1000);
   V_COLUMN_NAME                 VARCHAR2 (1000);
   V_DATATYPE                    VARCHAR2 (1000);
   V_COLUMN_DELIMITER_LOCATION   BINARY_INTEGER := 0;
   V_DATATYPE_DELIMITER_LOCATION BINARY_INTEGER := 0;
   V_COLUMN_COUNTER              BINARY_INTEGER := 0;
   V_CREATE_TABLE_SQL            VARCHAR2 (1000);
   V_DROP_TABLE_SQL              VARCHAR2 (1000);
   E_TABLE_CREATE_FAILED         EXCEPTION;
   E_NO_PRIVS                    EXCEPTION;
   PRAGMA EXCEPTION_INIT (E_TABLE_CREATE_FAILED,  -00955);
   V_ALTER_COLUMN_SQL            VARCHAR2 (1000);
   C_SELECT_ROW_CURSOR           T_COPY_CURSOR;
   V_SELECT_ROWS_SQL             VARCHAR2 (1000);
   V_DROP_ORIGINAL_TABLE_SQL     VARCHAR2 (1000);
   V_RENAME_TABLE_SQL            VARCHAR2 (1000);
   V_TABLESPACE_SQL              VARCHAR2 (1000);
   V_TABLESPACE                  VARCHAR2 (1000);
   V_ROWID                       VARCHAR2 (1000);
   V_COMMIT_CNT                  INTEGER;
   V_MAX_COMMIT                  INTEGER := 1000;
   V_COLUMN_POSITION             INTEGER;

   -- FOLLOWING VARIABLES ARE USED TO STORE THE TRIGGER INFORMATION
   -- THIS CURSOR IS USED TO GET ALL THE TRIGGERS FOR THIS TABLE
   CURSOR C_TRIGGERS
   IS
      SELECT   TRIGGER_NAME,
               DECODE (TRIGGER_TYPE, 'AFTER EACH ROW', 'AFTER', 'BEFORE EACH ROW', 'BEFORE', 'AFTER') TRIGGER_TYPE,
               TRIGGERING_EVENT,
               TABLE_NAME,
               REFERENCING_NAMES,
               TRIGGER_BODY
      FROM     USER_TRIGGERS
      WHERE    TABLE_NAME = UPPER (P_TABLE_NAME);

   CURSOR C_FUNCTION_BASED_INDEXES
   IS
      SELECT   UIC.INDEX_NAME,
               UIC.COLUMN_POSITION,
               E.COLUMN_EXPRESSION COLUMN_NAME,
               UI.TABLESPACE_NAME,
               UI.UNIQUENESS
      FROM     USER_IND_COLUMNS UIC,
               USER_INDEXES UI,
               USER_CONSTRAINTS UC,
               USER_IND_EXPRESSIONS E
      WHERE    UIC.TABLE_NAME = P_TABLE_NAME
      AND      UIC.TABLE_NAME = UI.TABLE_NAME
      AND      UIC.INDEX_NAME = UI.INDEX_NAME
      AND      UIC.TABLE_NAME = UC.TABLE_NAME
      AND      UC.CONSTRAINT_TYPE = 'P'
      AND      UI.INDEX_NAME &lt;&gt; UC.CONSTRAINT_NAME
      AND      UIC.COLUMN_NAME LIKE 'SYS%$'
      AND      E.INDEX_NAME = UI.INDEX_NAME
      AND      E.TABLE_NAME = UI.TABLE_NAME;

   CURSOR C_KEEP_DEFAULTS
   IS
      SELECT   COLUMN_NAME,
               DATA_DEFAULT
      FROM     USER_TAB_COLUMNS
      WHERE    TABLE_NAME = P_TABLE_NAME
      AND      DATA_DEFAULT IS NOT NULL;

   E_TRIGGER_FAILED_COMPILE      EXCEPTION;
   E_TRIGGER_INVALID             EXCEPTION;
   PRAGMA EXCEPTION_INIT (E_TRIGGER_FAILED_COMPILE,  -24344);
   PRAGMA EXCEPTION_INIT (E_TRIGGER_INVALID,  -04098);
   V_TRIGGER_NAME                VARCHAR2 (100);
   V_TRIGGER_TABLE_NAME          VARCHAR2 (100);
   V_TRIGGERING_EVENT            VARCHAR2 (32000);
   V_REFERENCING_NAMES           VARCHAR2 (32000);
   V_TRIGGER_TYPE                VARCHAR2 (32000);
   V_TRIGGER_BODY                VARCHAR2 (32000);
   V_CREATE_TRIGGER_SQL          VARCHAR2 (32000);
   V_CREATE_DEFAULT_SQL          VARCHAR2 (32000);
   V_TRIGGER_COUNTER             BINARY_INTEGER := 0;
   V_DEFAULT_COUNTER             BINARY_INTEGER := 0;

   TYPE V_SQL_REC_TYPE IS RECORD(
      SQL_STMT                      VARCHAR2 (32000));

   TYPE V_SQL_TAB_TYPE IS TABLE OF V_SQL_REC_TYPE
      INDEX BY BINARY_INTEGER;

   TYPE V_DEFAULT_TAB_TYPE IS TABLE OF V_SQL_REC_TYPE
      INDEX BY BINARY_INTEGER;

   V_TRIGGER_TAB                 V_SQL_TAB_TYPE;
   V_DEFAULT_TAB                 V_SQL_TAB_TYPE;
   I                             BINARY_INTEGER := 0;
   V_STMT                        VARCHAR2 (100);
   V_CNT                         INTEGER;
   V_IDX_COLUMN_NAME             VARCHAR2 (4000);
   V_PRIV_CNT                    INTEGER;
BEGIN
   SELECT   COUNT (*)
   INTO     V_PRIV_CNT
   FROM     USER_SYS_PRIVS
   WHERE    PRIVILEGE IN ('ALTER ANY TABLE', 'CREATE ANY INDEX', 'CREATE ANY TABLE', 'CREATE ANY TRIGGER');

   IF V_PRIV_CNT &lt;&gt; 4
   THEN
      RAISE E_NO_PRIVS;
   END IF;

   ----- Start of parsing the columns ----

   V_TABLE_NAME := UPPER (P_TABLE_NAME);
   V_COLUMN_NAME := UPPER (P_COLUMN_NAME);
   V_DATATYPE := UPPER (P_DATATYPE);
   V_COLUMN_COUNTER := 0;
   V_STMT := 'PARSING THE COLUMNS AND DATATYPES PASSED IN';

   IF    SUBSTR (V_COLUMN_NAME, LENGTH (V_COLUMN_NAME)) != '~'
      OR SUBSTR (V_DATATYPE, LENGTH (V_DATATYPE)) != '~'
   THEN
      RAISE_APPLICATION_ERROR (-20001, 'column name and datatype should end with ~');
   END IF;

   LOOP
      IF LENGTH (V_COLUMN_NAME) &gt; 0
      THEN
         V_COLUMN_DELIMITER_LOCATION := INSTR (V_COLUMN_NAME, '~', 1, 1);
         V_COLUMN_TAB (V_COLUMN_COUNTER).COLUMN_NAME := SUBSTR (V_COLUMN_NAME, 0, V_COLUMN_DELIMITER_LOCATION - 1);
         V_COLUMN_NAME := SUBSTR (V_COLUMN_NAME, V_COLUMN_DELIMITER_LOCATION + 1);
         V_DATATYPE_DELIMITER_LOCATION := INSTR (V_DATATYPE, '~', 1, 1);
         V_COLUMN_TAB (V_COLUMN_COUNTER).NEW_DATATYPE := SUBSTR (V_DATATYPE, 0, V_DATATYPE_DELIMITER_LOCATION - 1);
         V_DATATYPE := SUBSTR (V_DATATYPE, V_DATATYPE_DELIMITER_LOCATION + 1);
         V_COLUMN_COUNTER := V_COLUMN_COUNTER + 1;
      ELSE
         EXIT;
      END IF;
   END LOOP;

   ----- End of parsing the columns ----

   ----- Start of constructing the index select sql ----
      -- Get all the indexes which have the p_column names in it
   V_STMT := 'CONSTRUCTING THE INDEX SELECT SQL';
   -- Store function based index info into temporary table first  
   SELECT   COUNT (*)
   INTO     V_CNT
   FROM     USER_TABLES
   WHERE    TABLE_NAME = 'TEMP_FUNCTION_IDX';

   IF V_CNT &gt; 0
   THEN
      EXECUTE IMMEDIATE 'DELETE FROM TEMP_FUNCTION_IDX';
   ELSE
      EXECUTE IMMEDIATE 'CREATE TABLE temp_function_idx (index_name VARCHAR2(30), column_position NUMBER, column_name VARCHAR2(4000), tablespace_name  VARCHAR2(30), uniqueness VARCHAR2(9))';
   END IF;

   FOR C_REC IN C_FUNCTION_BASED_INDEXES
   LOOP
      V_IDX_COLUMN_NAME := C_REC.COLUMN_NAME;
      EXECUTE IMMEDIATE 'INSERT INTO TEMP_FUNCTION_IDX (INDEX_NAME, COLUMN_POSITION, COLUMN_NAME, TABLESPACE_NAME, UNIQUENESS) VALUES (' ||
                           '''' ||
                           C_REC.INDEX_NAME ||
                           ''', ' ||
                           C_REC.COLUMN_POSITION ||
                           ', ' ||
                           '''' ||
                           V_IDX_COLUMN_NAME ||
                           ''',' ||
                           '''' ||
                           C_REC.TABLESPACE_NAME ||
                           ''',' ||
                           '''' ||
                           C_REC.UNIQUENESS ||
                           ''')';
   END LOOP;

   V_INDEX_SELECT_SQL :=
     ' SELECT UIC.INDEX_NAME, UIC.COLUMN_POSITION, UIC.COLUMN_NAME, UI.TABLESPACE_NAME, UI.UNIQUENESS ' ||
        ' FROM   USER_IND_COLUMNS UIC, USER_INDEXES UI ' ||
        ' WHERE  UIC.TABLE_NAME     = ' ||
        '''' ||
        V_TABLE_NAME ||
        '''' ||
        ' AND     UIC.TABLE_NAME     = UI.TABLE_NAME ' ||
        ' AND    UIC.INDEX_NAME     = UI.INDEX_NAME ' ||
        ' AND    UIC.COLUMN_NAME NOT LIKE ''SYS%$'' ' ||
				' AND NOT EXISTS ( SELECT ''EXISTS'' ' ||
                           ' FROM USER_CONSTRAINTS UC ' ||
								           ' WHERE UC.CONSTRAINT_TYPE = ''P'' ' ||
								           ' AND   UC.CONSTRAINT_NAME = UIC.INDEX_NAME ' ||
								           ' AND   UC.TABLE_NAME = UIC.TABLE_NAME ) ' ||
        ' UNION ALL ' ||
        ' SELECT INDEX_NAME, COLUMN_POSITION, COLUMN_NAME, TABLESPACE_NAME, UNIQUENESS ' ||
        ' FROM TEMP_FUNCTION_IDX ' ||
        ' ORDER BY 1, 2';
   ----- Start of constructing the index create sql into the array ----
   V_STMT := 'STORING THE DROP INDEX AND CREATE INDEX SQL INTO ARRAY';
   -- SETTING THE INDEX RELATED VARIABLES TO NULL
   V_CREATE_INDEX_SQL := NULL;
   V_PREVIOUS_INDEX_NAME := NULL;
   V_DROP_INDEX_SQL := NULL;
   OPEN C_INDEXES_CURSOR FOR
      V_INDEX_SELECT_SQL;

   -- THE FOLLOWING LOOP IS USED FOR CONSTRUCTING THE SQLS FOR DROPPING AND REC-CREATING
   -- THE INDEXES WHICH HAVE THE COLUMN PASSED
   LOOP
      FETCH C_INDEXES_CURSOR INTO V_INDEX_NAME, V_COLUMN_POSITION, V_INDEX_COLUMN_NAME, V_INDEX_TABLESPACE, V_INDEX_UNIQUENESS;
      EXIT WHEN C_INDEXES_CURSOR%NOTFOUND;

      -- COMPARE IF THE PREVIOUS INDEX NAME IS SAME AS CURRENT ONE,
      -- IF IT IS NOT SAME THEN CONSTRUCTING THE CREATE INDEX SQL
      -- IS DONE FOR THE PREVIOUS INDEX, HENCE STORE IT IN THE
      -- ADD INDEXE TAB
      -- IF IT IS NOT SAME THEN APPEND THE COLUMN NAME TO THE
      -- CREATE INDEX SQL
      IF (V_INDEX_NAME &lt;&gt; NVL (V_PREVIOUS_INDEX_NAME, '-9'))
      THEN
         IF (V_CREATE_INDEX_SQL IS NOT NULL)
         THEN
            V_CREATE_INDEX_SQL := V_CREATE_INDEX_SQL || ' ) TABLESPACE ' || V_PREVIOUS_INDEX_TABLESPACE;
            CMN_ADD_INDEXES_TAB (NVL (CMN_ADD_INDEXES_TAB.LAST + 1, 0)) := V_CREATE_INDEX_SQL;
         END IF;

         V_DROP_INDEX_SQL := 'DROP INDEX ' || V_INDEX_NAME;
         V_PREVIOUS_INDEX_NAME := V_INDEX_NAME;
         V_PREVIOUS_INDEX_TABLESPACE := V_INDEX_TABLESPACE;
         CMN_DROP_INDEXES_TAB (NVL (CMN_DROP_INDEXES_TAB.LAST + 1, 0)) := V_DROP_INDEX_SQL;

         IF ('UNIQUE' = V_INDEX_UNIQUENESS)
         THEN
            V_CREATE_INDEX_SQL :=
                  'CREATE ' || V_INDEX_UNIQUENESS || ' INDEX ' || V_INDEX_NAME || ' ON ' || V_TABLE_NAME || ' ( ' || V_INDEX_COLUMN_NAME;
         ELSE
            V_CREATE_INDEX_SQL := 'CREATE INDEX ' || V_INDEX_NAME || ' ON ' || V_TABLE_NAME || ' ( ' || V_INDEX_COLUMN_NAME;
         END IF;
      ELSE
         V_CREATE_INDEX_SQL := V_CREATE_INDEX_SQL || ', ' || V_INDEX_COLUMN_NAME;
      END IF;
   END LOOP;

   CLOSE C_INDEXES_CURSOR;

   -- ADD THE LAST CREATE INDEX SQL, AS IT IS NOT ADDED IN THE ABOVE LOOP
   IF (V_CREATE_INDEX_SQL IS NOT NULL)
   THEN
      V_CREATE_INDEX_SQL := V_CREATE_INDEX_SQL || ' ) TABLESPACE ' || V_PREVIOUS_INDEX_TABLESPACE;
      CMN_ADD_INDEXES_TAB (NVL (CMN_ADD_INDEXES_TAB.LAST + 1, 0)) := V_CREATE_INDEX_SQL;
   END IF;

   ----- End of constructing the index create sql into the array ----

   -- DROP INDEXES
   V_STMT := 'DROPPING THE INDEXES';

   IF (NVL (CMN_DROP_INDEXES_TAB.LAST, -1) &lt;&gt; -1)
   THEN
      FOR I IN 0 .. CMN_DROP_INDEXES_TAB.LAST
      LOOP
         V_DROP_INDEX_SQL := CMN_DROP_INDEXES_TAB (I);
         EXECUTE IMMEDIATE V_DROP_INDEX_SQL;
      END LOOP;
   END IF;

   ----- Start of constructing the primary key sql ----
   V_STMT := 'CONSTRUCTING THE PRIMARY KEY SELECT SQL';
   V_PRIMARY_KEY_SQL :=
     'SELECT UC.CONSTRAINT_NAME, UCC.COLUMN_NAME, UI.TABLESPACE_NAME ' || 'FROM USER_CONSTRAINTS UC, ' || 'USER_CONS_COLUMNS UCC ' ||
        ' , USER_INDEXES UI ' ||
        'WHERE UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME ' ||
        'AND CONSTRAINT_TYPE = ''P'' ' ||
        'AND   UC.TABLE_NAME = ' ||
        '''' ||
        V_TABLE_NAME ||
        '''' ||
        ' AND UI.INDEX_NAME = UC.CONSTRAINT_NAME ';
   V_STMT := 'CONSTRUCTING THE PRIMARY KEY ALTER SQL';
   V_PRIMARY_KEY_COUNTER := 0;
   V_PRIMARY_KEY_CREATE_SQL := 'ALTER TABLE ' || V_TABLE_NAME || ' ADD CONSTRAINT ';
   OPEN C_PRIMARY_KEY_CURSOR FOR
      V_PRIMARY_KEY_SQL;

   LOOP
      FETCH C_PRIMARY_KEY_CURSOR INTO V_PK_CONSTRAINT_NAME, V_PK_COLUMN_NAME, V_PK_INDEX_SPACE;
      EXIT WHEN C_PRIMARY_KEY_CURSOR%NOTFOUND;

      IF V_PRIMARY_KEY_COUNTER = 0
      THEN
         V_PRIMARY_KEY_CREATE_SQL := V_PRIMARY_KEY_CREATE_SQL || V_PK_CONSTRAINT_NAME || ' PRIMARY KEY (' || V_PK_COLUMN_NAME;
      ELSE
         V_PRIMARY_KEY_CREATE_SQL := V_PRIMARY_KEY_CREATE_SQL || ' , ' || V_PK_COLUMN_NAME;
      END IF;

      V_PRIMARY_KEY_COUNTER := V_PRIMARY_KEY_COUNTER + 1;
   END LOOP;

   CLOSE C_PRIMARY_KEY_CURSOR;
   V_PRIMARY_KEY_CREATE_SQL := V_PRIMARY_KEY_CREATE_SQL || ' ) USING INDEX TABLESPACE ' || V_PK_INDEX_SPACE;
   V_STMT := 'DROPPING PRIMARY KEY';

   IF V_PRIMARY_KEY_COUNTER &gt; 0
   THEN
      V_PRIMARY_KEY_DROP_SQL := 'ALTER TABLE ' || V_TABLE_NAME || ' DROP CONSTRAINT ' || V_PK_CONSTRAINT_NAME;
      EXECUTE IMMEDIATE V_PRIMARY_KEY_DROP_SQL;
   END IF;

   ----- End of constructing the primary key sql ----

   V_STMT := 'DROPPING TRIGGERS';
   -- THIS LOOP IS USED TO GET ALL THE TRIGGER INFORMATION FOR THE TABLE PASSED
   -- AND STORE IT IN THE V_TRIGGER_TAB
   OPEN C_TRIGGERS;

   LOOP
      FETCH C_TRIGGERS INTO V_TRIGGER_NAME,
                            V_TRIGGER_TYPE,
                            V_TRIGGERING_EVENT,
                            V_TRIGGER_TABLE_NAME,
                            V_REFERENCING_NAMES,
                            V_TRIGGER_BODY;
      EXIT WHEN C_TRIGGERS%NOTFOUND;
      V_CREATE_TRIGGER_SQL := NULL;
      V_CREATE_TRIGGER_SQL :=
        'CREATE OR REPLACE TRIGGER ' || V_TRIGGER_NAME || CHR (10) || V_TRIGGER_TYPE || ' ' || V_TRIGGERING_EVENT || CHR (10) || 'ON ' ||
           V_TRIGGER_TABLE_NAME ||
           CHR (10) ||
           V_REFERENCING_NAMES ||
           CHR (10) ||
           'FOR EACH ROW ' ||
           CHR (10) ||
           V_TRIGGER_BODY;
      V_TRIGGER_TAB (V_TRIGGER_COUNTER).SQL_STMT := V_CREATE_TRIGGER_SQL;
      V_STMT := 'Dropping trigger ' || V_TRIGGER_NAME;
      EXECUTE IMMEDIATE 'DROP TRIGGER ' || V_TRIGGER_NAME;
      V_TRIGGER_COUNTER := V_TRIGGER_COUNTER + 1;
   END LOOP;

   CLOSE C_TRIGGERS;
   V_STMT := 'STORING DEFAULTS';

   -- THIS LOOP IS USED TO GET ALL THE DEFAULT INFORMATION FOR THE COLUMNNS

   FOR C_REC IN C_KEEP_DEFAULTS
   LOOP
      V_CREATE_DEFAULT_SQL := NULL;
      V_CREATE_DEFAULT_SQL := 'ALTER TABLE ' || P_TABLE_NAME || ' MODIFY ' || C_REC.COLUMN_NAME || ' DEFAULT ' || C_REC.DATA_DEFAULT;
      V_DEFAULT_TAB (V_DEFAULT_COUNTER).SQL_STMT := V_CREATE_DEFAULT_SQL;
      V_DEFAULT_COUNTER := V_DEFAULT_COUNTER + 1;
   END LOOP;

   V_STMT := 'GET THE TABLESPACE OF THE TABLE';
   V_TABLESPACE_SQL := ' SELECT TABLESPACE_NAME FROM USER_TABLES ' || ' WHERE TABLE_NAME = ' || '''' || V_TABLE_NAME || '''';
   EXECUTE IMMEDIATE V_TABLESPACE_SQL
      INTO V_TABLESPACE;
   -- Create the back up table, alter the columns and get the data from the orginal table --
   V_STMT := 'CREATING BACKUP TABLE';
   V_CREATE_TABLE_SQL :=
         ' CREATE TABLE ' || V_TABLE_NAME || '_X TABLESPACE ' || V_TABLESPACE || ' AS SELECT * FROM ' || V_TABLE_NAME || ' WHERE 1 = 2';
   V_DROP_TABLE_SQL := 'DROP TABLE ' || V_TABLE_NAME || '_X ';

   BEGIN
      EXECUTE IMMEDIATE V_CREATE_TABLE_SQL;
   EXCEPTION
      WHEN E_TABLE_CREATE_FAILED
      THEN
         EXECUTE IMMEDIATE V_DROP_TABLE_SQL;
         EXECUTE IMMEDIATE V_CREATE_TABLE_SQL;
   END;

   V_STMT := 'ALTERING THE COLUMNS OF THE BACKUP TABLE';

   FOR I IN 0 .. V_COLUMN_COUNTER - 1
   LOOP
      V_ALTER_COLUMN_SQL :=
        'ALTER TABLE ' || V_TABLE_NAME || '_X MODIFY ' || ' ( ' || V_COLUMN_TAB (I).COLUMN_NAME || ' ' || V_COLUMN_TAB (I).NEW_DATATYPE ||
           ' ) ';
      EXECUTE IMMEDIATE V_ALTER_COLUMN_SQL;
   END LOOP;

   V_STMT := 'MOVING THE DATA FROM THE ORIGINAL TABLE TO THE BACKUP TABLE';
   -- Move data from original table to _X table
   V_SELECT_ROWS_SQL := 'SELECT ROWID FROM ' || V_TABLE_NAME;
   V_COMMIT_CNT := 0;
   OPEN C_SELECT_ROW_CURSOR FOR
      V_SELECT_ROWS_SQL;

   LOOP
      FETCH C_SELECT_ROW_CURSOR INTO V_ROWID;
      EXIT WHEN C_SELECT_ROW_CURSOR%NOTFOUND;
      EXECUTE IMMEDIATE 'INSERT INTO ' || V_TABLE_NAME || '_X SELECT * FROM ' || V_TABLE_NAME || ' WHERE ROWID = :1 '
         USING V_ROWID;

      IF V_COMMIT_CNT &gt; V_MAX_COMMIT
      THEN
         COMMIT;
         V_COMMIT_CNT := 0;
      END IF;
   END LOOP;

   CLOSE C_SELECT_ROW_CURSOR;
   COMMIT;
   -- Drop the original table
   V_STMT := 'DROPPING THE ORIGINAL TABLE';
   V_DROP_ORIGINAL_TABLE_SQL := 'DROP TABLE ' || V_TABLE_NAME;
   EXECUTE IMMEDIATE V_DROP_ORIGINAL_TABLE_SQL;
   V_STMT := 'RENAMING THE BACKUP TABLE TO ORIGINAL TABLE';
   -- Rename the _X table to the original table
   V_RENAME_TABLE_SQL := 'RENAME ' || V_TABLE_NAME || '_X TO ' || V_TABLE_NAME;
   EXECUTE IMMEDIATE V_RENAME_TABLE_SQL;
   V_STMT := 'CREATING THE PRIMARY KEY';

   --Create the primary key
   IF V_PRIMARY_KEY_COUNTER &gt; 0
   THEN
      EXECUTE IMMEDIATE V_PRIMARY_KEY_CREATE_SQL;
   END IF;

   V_STMT := 'CREATING THE INDEXES';
	 
	 -- ADD INDEXES BACK
   IF (NVL (CMN_ADD_INDEXES_TAB.LAST, -1) &lt;&gt; -1)
   THEN
      FOR I IN 0 .. CMN_ADD_INDEXES_TAB.LAST
      LOOP
         V_CREATE_INDEX_SQL := CMN_ADD_INDEXES_TAB (I);
         EXECUTE IMMEDIATE V_CREATE_INDEX_SQL;
      END LOOP;
   END IF;

   V_INDEXES_RESTORED := TRUE;
   V_STMT := 'CREATING THE TRIGGERS';

   -- FOLLOWING LOOP IS USED TO RE-CREATE THE TRIGGERS FOR THE TABLE PASSED
   FOR I IN 0 .. V_TRIGGER_COUNTER - 1
   LOOP
      V_CREATE_TRIGGER_SQL := V_TRIGGER_TAB (I).SQL_STMT;

      BEGIN
         EXECUTE IMMEDIATE V_CREATE_TRIGGER_SQL;
      EXCEPTION
         WHEN E_TRIGGER_FAILED_COMPILE
         THEN
            NULL;
         WHEN E_TRIGGER_INVALID
         THEN
            NULL;
         WHEN OTHERS
         THEN
            RAISE;
      END;
   END LOOP;

   V_TRIGGER_RESTORED := TRUE;
   V_STMT := 'RESTORING DEFAULTS';

   FOR I IN 0 .. V_DEFAULT_COUNTER - 1
   LOOP
      V_CREATE_DEFAULT_SQL := V_DEFAULT_TAB (I).SQL_STMT;

      BEGIN
         EXECUTE IMMEDIATE V_CREATE_DEFAULT_SQL;
      EXCEPTION
         WHEN OTHERS
         THEN
            RAISE;
      END;
   END LOOP;
EXCEPTION
   WHEN E_NO_PRIVS
   THEN
      RAISE_APPLICATION_ERROR (
         -20001,
         'Error in CMN_MODIFY_COLUMN_DATATYPE_SP - USER DOES NOT HAVE ALTER ANY TABLE / CREATE ANY TABLE / CREATE ANY INDEX / CREATE ANY TRIGGER PRIVILEGES'
      );
   WHEN OTHERS
   THEN
      IF NOT V_TRIGGER_RESTORED
      THEN
         FOR I IN 0 .. V_TRIGGER_COUNTER - 1
         LOOP
            V_CREATE_TRIGGER_SQL := V_TRIGGER_TAB (I).SQL_STMT;

            BEGIN
               EXECUTE IMMEDIATE V_CREATE_TRIGGER_SQL;
            EXCEPTION
               WHEN E_TRIGGER_FAILED_COMPILE
               THEN
                  NULL;
               WHEN E_TRIGGER_INVALID
               THEN
                  NULL;
               WHEN OTHERS
               THEN
                  RAISE;
            END;
         END LOOP;
      END IF;

      IF NOT V_INDEXES_RESTORED
      THEN
         IF (NVL (CMN_ADD_INDEXES_TAB.LAST, -1) &lt;&gt; -1)
         THEN
            FOR I IN 0 .. CMN_ADD_INDEXES_TAB.LAST
            LOOP
               V_CREATE_INDEX_SQL := CMN_ADD_INDEXES_TAB (I);
               EXECUTE IMMEDIATE V_CREATE_INDEX_SQL;
            END LOOP;
         END IF;
      END IF;

      RAISE_APPLICATION_ERROR (-20000, 'Error in CMN_MODIFY_COLUMN_DATATYPE_SP - ' || V_STMT || ': ' || SQLERRM);
END;
 
 
 
 
 </definition>
        </Record>
      </Records>
      <Slice>
        <Number>0</Number>
        <Size>1</Size>
        <Total>1</Total>
      </Slice>
    </QueryResult>